{"version":3,"sources":["angular-hammer.js"],"names":[],"mappings":"CAAA,SAAA,EAAA,EAAA,GAEA,YAQA,SAAA,GAAA,EAAA,GACA,IAAA,EACA,KAAA,IAAA,OAAA,GAYA,QAAA,GAAA,GACA,MAAA,GAAA,OAAA,GAAA,cAAA,EAAA,MAAA,GASA,QAAA,GAAA,EAAA,GACA,MAAA,GAAA,MAAA,KAAA,IAAA,SAAA,EAAA,GACA,MAAA,IAAA,IAAA,EACA,EAAA,GADA,IAEA,KAAA,IAQA,QAAA,GAAA,GACA,MAAA,MAAA,EAAA,OAAA,EAAA,OAAA,GAYA,QAAA,GAAA,EAAA,GACA,GAAA,GAAA,EAAA,UAAA,EAAA,YACA,EAAA,IAaA,OAXA,GAAA,QAAA,SAAA,GACA,GAAA,EAAA,UAAA,IACA,EAAA,KAIA,IACA,EAAA,GAAA,GAAA,QAAA,GACA,EAAA,KAAA,IAGA,EAQA,QAAA,GAAA,GACA,GAAA,GAAA,EAAA,EACA,OAAA,GAAA,MAAA,EAAA,OAAA,EAAA,SAAA,GASA,QAAA,GAAA,EAAA,GACA,MAAA,GAAA,MAAA,GAUA,QAAA,GAAA,EAAA,EAAA,GACA,GAAA,GAAA,GAAA,EAAA,GAAA,MAAA,OACA,OAAA,GAAA,EAAA,EAAA,QAQA,QAAA,GAAA,GACA,MAAA,GAAA,QAAA,UAAA,GAQA,QAAA,GAAA,GACA,MAAA,GAAA,GAIA,EAAA,MAAA,UAAA,IAAA,SAAA,GACA,MAAA,GAAA,UAJA,EAAA,QAgBA,QAAA,GAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,EACA,OAAA,GACA,EAAA,GACA,EAAA,GAAA,GACA,GAWA,QAAA,GAAA,EAAA,EAAA,GACA,MAAA,GAAA,EAAA,IACA,EAAA,EAAA,EAAA,EAAA,IAAA,IAEA,EAAA,EAAA,EAAA,GAUA,QAAA,GAAA,EAAA,GACA,MAAA,UAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAEA,KAAA,EAEA,WADA,SAAA,KAAA,2CAAA,EAAA,IAIA,IAAA,GAAA,EAAA,EACA,GAAA,EAAA,GAAA,IAAA,EAAA,mCAEA,IAAA,GAAA,EAAA,OAAA,EAAA,oBACA,GAAA,MACA,EAAA,EAAA,QAAA,MAAA,GAAA,EAEA,IAAA,GAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,SAAA,GACA,EAAA,GAAA,SAAA,KAEA,SAAA,GACA,EAAA,OAAA,WACA,EAAA,GAAA,SAAA,OAKA,EAAA,GAAA,GAAA,GAAA,EACA,GAAA,IAAA,GACA,EAAA,GAAA,EAAA,GAEA,EAAA,IAAA,WAAA,WACA,EAAA,IAAA,EAAA,EAEA,IAAA,GAAA,OAAA,KAAA,EAAA,QAAA,UAAA,MACA,KAAA,GACA,EAAA,aAjMA,EAAA,EAAA,6BACA,EAAA,EAAA,2BA0MA,IAAA,GAAA,EAAA,OAAA,aAKA,EAAA,KAMA,GACA,MACA,QACA,QACA,UACA,QACA,SACA,WACA,QACA,MAGA,GAAA,QAAA,SAAA,GACA,GAAA,GAAA,EAAA,EAAA,IAAA,EAEA,GAAA,UAAA,GAAA,SAAA,SAAA,GACA,OACA,SAAA,IACA,KAAA,EAAA,EAAA,UAKA,OAAA,OAAA,QAAA,OAAA","file":"angular-hammer.min.js","sourcesContent":[";(function (window, angular, Hammer) {\n\n'use strict';\n\n/**\n * Throws error when a condition in not truthy.\n * @param  {Any}    cond\n * @param  {String} message\n * @return {Error|Null}\n */\nfunction assert(cond, message) {\n  if (!cond) {\n    throw new Error(message);\n  }\n}\n\nassert(angular, '`angular` is not defined.');\nassert(Hammer, '`Hammer` is not defined.');\n\n/**\n * Capitalizes string.\n * @param  {String} str\n * @return {String}\n */\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Converts directive name in HTML form to JS form.\n * @param  {String}  directive\n * @param  {Boolean} all Should capitalize all items.\n * @return {String}\n */\nfunction toJSDirective(directive, all) {\n  return directive.split('-').map(function (item, i) {\n    if (!all && i === 0) return item;\n    return capitalize(item);\n  }).join('');\n}\n\n/**\n * Checks if a given directive is optimized.\n * @param  {String}  d directive\n * @return {Boolean}\n */\nfunction isOptimized(d) {\n  return d.charAt(d.length - 1) === 'O';\n}\n\n/**\n * Retrives or creates a `Hammer.Manager`.\n * @param  {Object}      scope\n * @param  {HTMLElement} element\n * @return {Object}      `Hammer.Manager` instance\n *\n * @todo `$hammer` should be an object to support methods\n *                 to retrieve `Hammer.Manager` isntances.\n */\nfunction hammerManagerFromScope(scope, element) {\n  var managers = scope.$hammer || (scope.$hammer = []);\n  var found = null;\n\n  managers.forEach(function (m) {\n    if (!found && m.element === element) {\n      found = m;\n    }\n  });\n\n  if (!found) {\n    found = new Hammer.Manager(element);\n    managers.push(found);\n  }\n\n  return found;\n}\n\n/**\n * Converts directive to Hammer.JS recognizer name.\n * @param  {String} d          directive\n * @return {String}\n */\nfunction recognizerFromDirective(d) {\n  var optimized = isOptimized(d);\n  return d.slice(prefix.length, d.length - !!optimized);\n}\n\n/**\n * Parses expression using `$evel`.\n * @param  {Object} scope\n * @param  {String} expr\n * @return {Object}\n */\nfunction parseOptionsExpr(scope, expr) {\n  return scope.$eval(expr);\n}\n\n/**\n * Retrives options for a given directive (if exists).\n * @param  {Object}  scope\n * @param  {Object}  attr   directive's attributes\n * @param  {String}  d\n * @return {Object}\n */\nfunction hammerOpts(scope, attr, d) {\n  var optsDirective = d + (isOptimized(d) ? 'pts' : 'Opts');\n  return parseOptionsExpr(scope, attr[optsDirective]) || {};\n}\n\n/**\n * Checks whether an expression has a `with` keyword.\n * @param  {String}  expr\n * @return {Boolean}\n */\nfunction hasWithToken(expr) {\n  return expr.indexOf(' with ') > -1;\n}\n\n/**\n * Splits an expression.\n * @param  {String} expr\n * @return {Array}\n */\nfunction splitExpr(expr) {\n  if (!hasWithToken(expr)) {\n    return [expr.trim()];\n  }\n\n  return expr.split(' with ').map(function (expr) {\n    return expr.trim();\n  });\n}\n\n/**\n * Retrives directive callback form `attr` object.\n * @param  {Function} $parse\n * @param  {Object} scope\n * @param  {Object} attr\n * @param  {String} d        directive name\n * @return {Function}        directive callback\n */\nfunction directiveCallback($parse, scope, attr, d) {\n  var dirVal = attr[d];\n  return $parse(\n    hasWithToken(dirVal)\n      ? splitExpr(dirVal)[0]\n      : dirVal\n  );\n}\n\n/**\n * Retrives directives options.\n * @param  {Object} scope\n * @param  {Object} attr\n * @param  {String} d     directive name\n * @return {Object}       options object passed to HammerJS\n */\nfunction directiveOptions(scope, attr, d) {\n  if (hasWithToken(attr[d])) {\n    return parseOptionsExpr(scope, splitExpr(attr[d])[1]);\n  } else {\n    return hammerOpts(scope, attr, d);\n  }\n}\n\n/**\n * Constructs link function passed to the directive definition.\n * @param  {Function} $parse\n * @param  {String}   directive directive name\n * @return {Function}           link function\n */\nfunction constructLinkFn($parse, directive) {\n  return function linkFn(scope, element, attr) {\n    var callback = directiveCallback($parse, scope, attr, directive);\n    var opts = directiveOptions(scope, attr, directive);\n\n    if (!callback) {\n      console.warn('[ linkFn ] no callback for directive = `' + directive + '`');\n      return;\n    }\n\n    var recognizer = recognizerFromDirective(directive);\n    assert(Hammer[recognizer], '`' + recognizer + '` is not supported by Hammer.js.');\n\n    var eventName = opts.event || recognizer.toLowerCase();\n    delete opts.event;\n    opts = angular.extend({ event: eventName }, opts);\n\n    var $hammer = hammerManagerFromScope(scope, element[0]);\n    var fn = isOptimized(directive)\n      ? function eventCallbackOptimized(ev) {\n          callback(scope, { $hmEvent: ev });\n        }\n      : function eventCallbackNotOptimized(ev) {\n          scope.$apply(function () {\n            callback(scope, { $hmEvent: ev });\n          });\n        };\n\n    // @TODO: it's possible to add multiple recognizers of the same type.\n    var recognizerInstance = new Hammer[recognizer](opts);\n    $hammer.add(recognizerInstance);\n    $hammer.on(eventName, fn);\n\n    scope.$on('$destroy', function () {\n      $hammer.off(eventName, fn);\n\n      var left = Object.keys(recognizerInstance.manager.handlers).length;\n      if (left === 0) {\n        $hammer.destroy();\n      }\n    });\n  };\n}\n\n/**\n * @module hammer\n * @type {Object}\n */\nvar module = angular.module('hammer', []);\n\n/**\n * @const {String}\n */\nvar prefix = 'hm';\n\n/**\n * List of all available recognizers defined by Hammer.\n * @type {Array}\n */\nvar RECOGNIZERS = [\n  'pan',\n  'pan-o',\n  'pinch',\n  'pinch-o',\n  'press',\n  'rotate',\n  'rotate-o',\n  'swipe',\n  'tap'\n];\n\nRECOGNIZERS.forEach(function (recognizer) {\n  var directive = toJSDirective(prefix + '-' + recognizer);\n\n  module.directive(directive, ['$parse', function ($parse) {\n    return {\n      restrict: 'A',\n      link: constructLinkFn($parse, directive)\n    };\n  }]);\n});\n\n}(window, window.angular, window.Hammer));\n"],"sourceRoot":"/source/"}