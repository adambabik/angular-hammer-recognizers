{"version":3,"sources":["angular-hammer.js"],"names":[],"mappings":"CAAA,SAAA,EAAA,EAAA,GAEA,YAIA,SAAA,GAAA,EAAA,GACA,IAAA,EACA,KAAA,IAAA,OAAA,GAYA,QAAA,GAAA,GACA,MAAA,GAAA,OAAA,GAAA,cAAA,EAAA,MAAA,GAQA,QAAA,GAAA,EAAA,GACA,MAAA,GAAA,MAAA,KAAA,IAAA,SAAA,EAAA,GACA,MAAA,IAAA,IAAA,EACA,EAAA,GADA,IAEA,KAAA,IAQA,QAAA,GAAA,GACA,MAAA,MAAA,EAAA,OAAA,EAAA,OAAA,GASA,QAAA,GAAA,EAAA,GACA,MAAA,GAAA,UAAA,EAAA,QAAA,GAAA,GAAA,QAAA,EAAA,KAQA,QAAA,GAAA,GACA,GAAA,GAAA,EAAA,EACA,OAAA,GAAA,MAAA,EAAA,OAAA,EAAA,SAAA,GAGA,QAAA,GAAA,EAAA,GACA,MAAA,GAAA,MAAA,GAUA,QAAA,GAAA,EAAA,EAAA,GACA,GAAA,GAAA,GAAA,EAAA,GAAA,MAAA,OACA,OAAA,GAAA,EAAA,EAAA,QAGA,QAAA,GAAA,GACA,MAAA,GAAA,QAAA,UAAA,GAGA,QAAA,GAAA,GACA,MAAA,GAAA,MAAA,UAAA,IAAA,SAAA,GACA,MAAA,GAAA,SAIA,QAAA,GAAA,EAAA,EAAA,EAAA,GACA,GAAA,KAEA,OAAA,GAAA,EAAA,KACA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,KAEA,EAAA,EAAA,IAIA,QAAA,GAAA,EAAA,EAAA,GACA,GAAA,KAEA,OAAA,GAAA,EAAA,KACA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,KAEA,EAAA,EAAA,EAAA,GAIA,QAAA,GAAA,EAAA,GACA,MAAA,UAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAEA,KAAA,EAEA,WADA,SAAA,KAAA,2CAAA,EAAA,IAIA,IAAA,GAAA,EAAA,EACA,GAAA,EAAA,GAAA,IAAA,EAAA,mCAEA,IAAA,GAAA,EAAA,aACA,GAAA,EAAA,OAAA,GAAA,MAAA,IAEA,GACA,QAAA,IAAA,cACA,UAAA,EACA,UAAA,EAAA,GACA,MAAA,EACA,KAAA,GAIA,IAAA,GAAA,EAAA,EAAA,EACA,GAAA,IAAA,GAAA,GAAA,GAAA,IACA,EAAA,GAAA,EAAA,SAAA,GACA,MAAA,GACA,SAAA,GACA,EAAA,GAAA,QAAA,KAGA,SAAA,GACA,EAAA,OAAA,WACA,EAAA,GAAA,QAAA,QAIA,EAAA,MApJA,GAAA,IAAA,CAQA,GAAA,EAAA,6BACA,EAAA,EAAA,2BAmJA,IAAA,GAAA,EAAA,OAAA,aAKA,EAAA,KAMA,GACA,MACA,QACA,QACA,UACA,QACA,SACA,WACA,QACA,MAGA,GAAA,QAAA,SAAA,GACA,GAAA,GAAA,EAAA,EAAA,IAAA,EAEA,GAAA,UAAA,GAAA,SAAA,SAAA,GACA,OACA,SAAA,KACA,KAAA,EAAA,EAAA,UAKA,OAAA,OAAA,QAAA,OAAA","file":"angular-hammer.min.js","sourcesContent":[";(function (window, angular, Hammer) {\n\n'use strict';\n\nvar DEBUG_LOGS = false;\n\nfunction assert(cond, message) {\n  if (!cond) {\n    throw new Error(message);\n  }\n}\n\nassert(angular, '`angular` is not defined.');\nassert(Hammer, '`Hammer` is not defined.');\n\n/**\n * Capitalizes string.\n * @param  {String} str\n * @return {String}\n */\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Converts directive name in HTML form to JS form.\n * @param  {String} directive\n * @return {String}\n */\nfunction toJSDirective(directive, all) {\n  return directive.split('-').map(function (item, i) {\n    if (!all && i === 0) return item;\n    return capitalize(item);\n  }).join('');\n}\n\n/**\n * Checks if a given directive is optimized.\n * @param  {String}  d directive\n * @return {Boolean}\n */\nfunction isOptimized(d) {\n  return d.charAt(d.length - 1) === 'O';\n}\n\n/**\n * Retrives or creates a `Hammer.Manager`.\n * @param  {Object}      scope\n * @param  {HTMLElement} element\n * @return {Object}\n */\nfunction hammerManagerFromScope(scope, element) {\n  return scope.$hammer || (scope.$hammer = new Hammer.Manager(element[0]));\n}\n\n/**\n * Converts directive to Hammer.JS recognizer name.\n * @param  {String} d          directive\n * @return {String}\n */\nfunction recognizerFromDirective(d) {\n  var optimized = isOptimized(d);\n  return d.slice(prefix.length, d.length - !!optimized);\n}\n\nfunction parseOptionsExpr(scope, expr) {\n  return scope.$eval(expr);\n}\n\n/**\n * Retrives options for a given directive (if exists).\n * @param  {Object}  scope\n * @param  {Object}  attr      directive's attributes\n * @param  {String}  d\n * @return {Object}\n */\nfunction hammerOpts(scope, attr, d) {\n  var optsDirective = d + (isOptimized(d) ? 'pts' : 'Opts');\n  return parseOptionsExpr(scope, attr[optsDirective]) || {};\n}\n\nfunction hasWithToken(expr) {\n  return expr.indexOf(' with ') > -1;\n}\n\nfunction splitExpr(expr) {\n  return expr.split(' with ').map(function (expr) {\n    return expr.trim();\n  });\n}\n\nfunction directiveCallback($parse, scope, attr, d) {\n  var splitAttr = [];\n\n  if (hasWithToken(attr[d])) {\n    splitAttr = splitExpr(attr[d]);\n    return $parse(splitAttr[0]);\n  } else {\n    return $parse(attr[d]);\n  }\n}\n\nfunction directiveOptions(scope, attr, d) {\n  var splitAttr = [];\n\n  if (hasWithToken(attr[d])) {\n    splitAttr = splitExpr(attr[d]);\n    return parseOptionsExpr(scope, splitAttr[1]);\n  } else {\n    return hammerOpts(scope, attr, d);\n  }\n}\n\nfunction constructLinkFn($parse, directive) {\n  return function linkFn(scope, element, attr) {\n    var callback = directiveCallback($parse, scope, attr, directive);\n    var opts = directiveOptions(scope, attr, directive);\n\n    if (!callback) {\n      console.warn('[ linkFn ] no callback for directive = `' + directive + '`');\n      return;\n    }\n\n    var recognizer = recognizerFromDirective(directive);\n    assert(Hammer[recognizer], '`' + recognizer + '` is not supported by Hammer.js.');\n\n    var eventName = recognizer.toLowerCase();\n    opts = angular.extend(opts, { event: eventName });\n\n    if (DEBUG_LOGS) {\n      console.log('[ linkFn ]', {\n        directive: directive,\n        optimized: isOptimized(directive),\n        event: eventName,\n        opts: opts\n      });\n    }\n\n    var $hammer = hammerManagerFromScope(scope, element);\n    $hammer.add(new Hammer[recognizer](opts));\n    $hammer.on(eventName, (function (optimized) {\n      if (optimized) {\n        return function eventCallbackOptimized(ev) {\n          callback(scope, { hmEvent: ev });\n        };\n      } else {\n        return function eventCallbackNotOptimized(ev) {\n          scope.$apply(function () {\n            callback(scope, { hmEvent: ev });\n          });\n        };\n      }\n    }(isOptimized(directive))));\n  };\n}\n\n/**\n * @module hammer\n * @type {Object}\n */\nvar module = angular.module('hammer', []);\n\n/**\n * @const {String}\n */\nvar prefix = 'hm';\n\n/**\n * List of all available recognizers defined by Hammer.\n * @type {Array}\n */\nvar RECOGNIZERS = [\n  'pan',\n  'pan-o',\n  'pinch',\n  'pinch-o',\n  'press',\n  'rotate',\n  'rotate-o',\n  'swipe',\n  'tap'\n];\n\nRECOGNIZERS.forEach(function (recognizer) {\n  var directive = toJSDirective(prefix + '-' + recognizer);\n\n  module.directive(directive, ['$parse', function ($parse) {\n    return {\n      restrict: 'AC',\n      link: constructLinkFn($parse, directive)\n    };\n  }]);\n});\n\n}(window, window.angular, window.Hammer));\n"],"sourceRoot":"/source/"}